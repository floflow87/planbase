Voici le prompt isolÃ©, prÃªt Ã  Ãªtre copiÃ©-collÃ© tel quel ğŸ‘‡

â¸»

ğŸ¯ PROMPT REPLIT â€” SUPPRIMER LE DÃ‰LAI Dâ€™AFFICHAGE APRÃˆS MODIFICATION (UI INSTANTANÃ‰E)

Tu es lâ€™agent Replit chargÃ© de supprimer tout dÃ©lai perceptible entre une modification de donnÃ©e (mutation API) et son affichage dans lâ€™interface utilisateur.

Objectif : UX instantanÃ©e.
DÃ¨s quâ€™un utilisateur modifie une donnÃ©e, lâ€™UI doit se mettre Ã  jour immÃ©diatement, puis se synchroniser avec le backend en arriÃ¨re-plan.

â¸»

1ï¸âƒ£ Audit des flux de donnÃ©es

Identifier les Ã©crans oÃ¹ un dÃ©lai est ressenti (ex : Notes, Projets, Backlog, Settings, Config, Temps) et analyser pour chacun :
	â€¢	les queries React Query utilisÃ©es
	â€¢	les mutations associÃ©es
	â€¢	les clÃ©s de cache (queryKey)
	â€¢	les invalidations existantes (ou absentes)

â¸»

2ï¸âƒ£ Standardisation des query keys

Mettre en place une convention stricte et cohÃ©rente pour toutes les queries.

Exemples :
	â€¢	['projects']
	â€¢	['project', projectId]
	â€¢	['projectTime', projectId]
	â€¢	['notes']
	â€¢	['note', noteId]
	â€¢	['tasks', projectId]
	â€¢	['config']

Supprimer toute key ambiguÃ« ou incohÃ©rente (strings isolÃ©es, clÃ©s partielles).

â¸»

3ï¸âƒ£ Invalidation ciblÃ©e systÃ©matique

AprÃ¨s chaque mutation :
	â€¢	invalider uniquement les queries concernÃ©es

Exemples :
	â€¢	update projet â†’ invalider ['project', id] + ['projects']
	â€¢	update note â†’ invalider ['note', id] + ['notes']
	â€¢	update task â†’ invalider ['tasks', projectId]

Ã‰viter les invalidations globales inutiles.

â¸»

4ï¸âƒ£ Optimistic updates (prioritÃ© absolue)

Pour toutes les mutations frÃ©quentes (update projet, note, tÃ¢che, config, temps) :

Mettre en place un optimistic update avec React Query :
	â€¢	onMutate :
	â€¢	cancelQueries sur la query concernÃ©e
	â€¢	sauvegarder un snapshot de lâ€™Ã©tat prÃ©cÃ©dent
	â€¢	appliquer immÃ©diatement la nouvelle valeur via setQueryData
	â€¢	onError :
	â€¢	rollback vers le snapshot prÃ©cÃ©dent
	â€¢	afficher un toast dâ€™erreur
	â€¢	onSuccess :
	â€¢	synchroniser le cache avec la rÃ©ponse serveur si nÃ©cessaire
	â€¢	onSettled :
	â€¢	invalider la query pour garantir la vÃ©ritÃ© backend

â¸»

5ï¸âƒ£ RÃ©glage du cache (staleTime)

VÃ©rifier et ajuster :
	â€¢	staleTime
	â€¢	refetchOnWindowFocus
	â€¢	refetchOnReconnect

But :
	â€¢	Ã©viter les donnÃ©es trop longtemps â€œstaleâ€
	â€¢	sans provoquer de refetch agressif inutile

â¸»

6ï¸âƒ£ Feedback UX explicite

Sur les Ã©crans avec autosave ou debounce :
	â€¢	afficher clairement lâ€™Ã©tat :
	â€¢	â€œEnregistrementâ€¦â€ (pending)
	â€¢	â€œSauvegardÃ©â€ (succÃ¨s)
	â€¢	â€œErreurâ€ (Ã©chec)

Ce feedback doit Ãªtre visible mais discret, sans bloquer lâ€™Ã©criture.

â¸»

7ï¸âƒ£ VÃ©rification cÃ´tÃ© backend

Auditer les services backend utilisant :
	â€¢	cache in-memory
	â€¢	agrÃ©gation de donnÃ©es

Sâ€™assurer que :
	â€¢	les donnÃ©es retournÃ©es aprÃ¨s update sont immÃ©diatement Ã  jour
	â€¢	toute couche de cache est invalidÃ©e correctement et sans dÃ©lai

â¸»

8ï¸âƒ£ CritÃ¨res dâ€™acceptation

La tÃ¢che est validÃ©e si :
	â€¢	lâ€™UI se met Ã  jour immÃ©diatement aprÃ¨s modification
	â€¢	aucun refresh manuel nâ€™est nÃ©cessaire
	â€¢	les erreurs serveur provoquent un rollback propre
	â€¢	les donnÃ©es restent cohÃ©rentes entre les vues
	â€¢	lâ€™expÃ©rience est fluide et perÃ§ue comme â€œinstantanÃ©eâ€

â¸»

Intention produit :
Lâ€™interface ne doit jamais donner lâ€™impression de â€œrÃ©flÃ©chirâ€.
Lâ€™utilisateur agit â†’ lâ€™app rÃ©pond immÃ©diatement.