Objectif
Construire un â€œCahier de recetteâ€ dans lâ€™onglet Recette du module Product, inspirÃ© de lâ€™esprit des RÃ©tros : je sÃ©lectionne un ou plusieurs sprints (y compris terminÃ©s), et PlanBase affiche ensuite une vue table de tous les tickets de ces sprints, dÃ©coupÃ©e par sprint, pour piloter la QA/recette et pousser des retours directement dans les tickets (via commentaires).

UX attendue (comportement)
1) SÃ©lection des sprints
- En haut de lâ€™onglet Recette : un sÃ©lecteur multi-sprints (multi-select) similaire Ã  celui des rÃ©tros.
- Le sÃ©lecteur doit permettre :
  - choisir 1 sprint ou plusieurs
  - inclure des sprints â€œterminÃ©sâ€
- Une fois la sÃ©lection validÃ©e, afficher la page â€œCahier de recetteâ€.

2) Affichage dÃ©coupÃ© par sprint
- La table est affichÃ©e en sections : 1 bloc par sprint sÃ©lectionnÃ©.
- Chaque bloc sprint contient :
  - header du sprint : nom, statut (en cours/terminÃ©), dates si dispo, mÃ©triques rapides (nb tickets, nb â€œTestÃ©â€, nb â€œFixÃ©/TerminÃ©â€)
  - puis la table des tickets de ce sprint.
- Si plusieurs sprints sÃ©lectionnÃ©s : afficher les blocs dans lâ€™ordre chronologique (ou par position), avec un sommaire en haut (â€œSprints sÃ©lectionnÃ©s (3)â€).

3) Contenu de la table (colonnes)
Dans chaque sprint, afficher un tableau avec colonnes :

Colonnes â€œticketâ€ (lecture)
- Titre du ticket (cliquable vers la fiche ticket)
- Description du ticket (preview 2-3 lignes + â€œvoir plusâ€)
Optionnel: tags / prioritÃ© / estimation (si dÃ©jÃ  existant) mais ne pas surcharger.

Colonnes â€œrecetteâ€ (modifiables)
A) Statut (select)
- Valeurs : â€œÃ€ testerâ€, â€œEn testâ€, â€œTestÃ©â€
- Valeur par dÃ©faut : â€œÃ€ testerâ€
- Affichage en badge lÃ©ger (couleur douce) + select editable inline.

B) RÃ©sultats observÃ©s (texte)
- Champ texte (multi-line) Ã©ditable inline (textarea autosize)
- Bouton â€œEnvoyer au ticketâ€ (ou auto-envoi au blur + debounce)
- Ã€ chaque envoi : crÃ©er un commentaire dans le ticket avec un format standardisÃ© (voir format plus bas).
- Le texte reste Ã©galement stockÃ© cÃ´tÃ© â€œrecetteâ€ pour historiser (et rÃ©-Ã©diter).

C) Conclusion (select)
- Valeurs : â€œÃ€ amÃ©liorerâ€, â€œÃ€ fixâ€, â€œÃ€ ajouterâ€
- Affichage badge + select editable inline.

D) Suggestions (texte)
- Champ texte multi-line Ã©ditable inline (textarea autosize)
- Ã€ lâ€™envoi : push un commentaire dans le ticket avec le format standardisÃ©.
- Stocker aussi dans lâ€™objet recette.

E) FixÃ© / TerminÃ© (checkbox)
- Checkbox binaire.
- Si cochÃ©e, indique que le point de recette est clÃ´turÃ©.
- Ne doit PAS automatiquement fermer le ticket (sauf si une rÃ¨gle existe dÃ©jÃ ). Par dÃ©faut, câ€™est juste un statut de recette.
- Visuel : ligne â€œmuteâ€ quand cochÃ© + badge â€œClÃ´turÃ©â€.

4) Interconnexion ticket (commentaires)
- Quand lâ€™utilisateur remplit â€œRÃ©sultats observÃ©sâ€ ou â€œSuggestionsâ€, PlanBase doit pousser un commentaire dans le ticket (table commentaires existante).
- Le commentaire doit prÃ©ciser :
  - que Ã§a vient du cahier de recette
  - le sprint concernÃ©
  - le statut de recette / conclusion au moment de lâ€™envoi

Format de commentaire standard (Ã  respecter)
[ğŸ§ª Recette] Sprint: <Nom Sprint>
Statut: <Ã€ tester | En test | TestÃ©>
Conclusion: <Ã€ amÃ©liorer | Ã€ fix | Ã€ ajouter>

RÃ©sultats observÃ©s:
<texte>

Suggestions:
<texte>

- Si seul â€œRÃ©sultats observÃ©sâ€ est envoyÃ©, ne pas inclure â€œSuggestionsâ€ vide (et inversement).
- Ajouter un lien interne (si existant) vers la vue recette/sprint.

5) RÃ¨gles de persistance (donnÃ©es)
- Chaque ticket doit pouvoir avoir un â€œÃ©tat de recetteâ€ par sprint (ou au moins par sprint sÃ©lectionnÃ©) :
  - statutRecette
  - resultatsObserves
  - conclusion
  - suggestions
  - isFixedDone
  - updatedAt / updatedBy
- Important : un mÃªme ticket peut exister dans un seul sprint (normalement), mais prÃ©voir la robustesse si un ticket est dÃ©placÃ© de sprint : on conserve son historique de recette associÃ© au sprint dâ€™origine.

6) Ergonomie & qualitÃ© (petites choses qui changent tout)
- Sauvegarde en optimistic update pour toutes les colonnes modifiables.
- Indicateur discret â€œEnregistrementâ€¦â€ / â€œEnregistrÃ©â€ dans la ligne quand on Ã©dite.
- Tri/filtre rapide :
  - Filtrer par Statut (Ã€ tester / En test / TestÃ©)
  - Filtrer par Conclusion
  - Afficher seulement â€œnon clÃ´turÃ©sâ€
- Raccourcis :
  - Enter = nouvelle ligne dans textarea (pas valider)
  - Cmd/Ctrl+Enter = envoyer au ticket
- Gestion des grandes descriptions :
  - description preview + popover ou drawer â€œVoir dÃ©tails ticketâ€.

7) Cas particuliers
- Sprints terminÃ©s : inclus dans le sÃ©lecteur + affichage identique, mais mention â€œSprint terminÃ©â€ dans le header.
- Ticket sans description : afficher â€œâ€”â€.
- Permissions : seuls les utilisateurs ayant accÃ¨s au backlog peuvent Ã©diter la recette.
- Si erreur API lors dâ€™un push commentaire : rollback de lâ€™UI + toast dâ€™erreur explicite.

8) ImplÃ©mentation technique attendue (sans surcharger)
- CrÃ©er une table dÃ©diÃ©e recette, ex: `ticket_test_cases` ou `ticket_recipes`:
  - id, backlogId, sprintId, ticketId
  - status (enum)
  - observedResults (text)
  - conclusion (enum)
  - suggestions (text)
  - isFixedDone (boolean)
  - createdAt, updatedAt, updatedBy
- Endpoints API sÃ©curisÃ©s :
  - GET /api/recipes?sprintIds=... -> retourne les lignes recette + tickets
  - POST /api/recipes/upsert -> upsert recette par ticketId+sprintId
  - POST /api/tickets/:id/comments (dÃ©jÃ  existant sinon Ã  crÃ©er) -> ajout commentaire
- Front : nouvelle page/section dans lâ€™onglet Recette + composants table rÃ©utilisables.

Definition of Done
- Je peux sÃ©lectionner 1 ou plusieurs sprints (y compris terminÃ©s) et voir une table par sprint.
- Je peux Ã©diter statut / rÃ©sultats / conclusion / suggestions / checkbox.
- Les champs texte poussent un commentaire dans le ticket avec le format standard.
- Les donnÃ©es de recette persistent et se rechargent correctement.
- Les filtres permettent dâ€™isoler rapidement ce quâ€™il reste Ã  tester.
- UX fluide (optimistic updates + feedback enregistrement).
